#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// module.ts
var module_exports = {};
__export(module_exports, {
  default: () => module_default
});
module.exports = __toCommonJS(module_exports);
var import_safe = require("@colors/colors/safe");

// downloadMainRepo.ts
var import_path = __toESM(require("path"));
var import_util = __toESM(require("util"));
var import_shelljs = __toESM(require("shelljs"));

// pullSource.ts
function pullSource(branch) {
  return `git pull origin --quiet ${branch} --depth 1`;
}

// downloadMainRepo.ts
var exec = import_util.default.promisify(import_shelljs.default.exec);
async function downloadMainRepo(outputDirectory, { owner, project }) {
  const projectPath = import_path.default.join(outputDirectory, project);
  import_shelljs.default.mkdir("-p", projectPath);
  import_shelljs.default.cd(projectPath);
  await exec("git init --quiet");
  await exec(`git remote add origin https://github.com/${owner}/${project}`);
  const branches = ["main", "master"];
  let success = false;
  for (const branch of branches) {
    try {
      await exec(pullSource(branch));
      success = true;
      console.log(`Successfully pulled from branch '${branch}'.`);
      break;
    } catch (error) {
      console.log(
        `Failed to pull using branch '${branch}'. Trying next option...`
      );
    }
  }
  if (!success) {
    console.error(
      "Error: Could not determine the default branch or failed to pull from it."
    );
    process.exit(1);
  }
  import_shelljs.default.rm("-rf", ".git");
}

// downloadPartialRepo.ts
var import_path2 = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var import_util2 = __toESM(require("util"));
var import_shelljs2 = __toESM(require("shelljs"));
var exec2 = import_util2.default.promisify(import_shelljs2.default.exec);
async function downloadPartialRepo(outputDirectory, { owner, project, filePath, branch }) {
  const tempDownloadName = ".go-git-it-temp-folder";
  const tempDownloadPath = import_path2.default.join(outputDirectory, tempDownloadName);
  import_shelljs2.default.mkdir("-p", tempDownloadPath);
  import_shelljs2.default.cd(tempDownloadPath);
  await exec2("git init --quiet");
  await exec2(`git remote add origin https://github.com/${owner}/${project}`);
  await exec2("git config core.sparseCheckout true");
  const isFile = filePath.includes(".");
  const sparsePath = isFile ? filePath : `${filePath}/*`;
  import_fs.default.writeFileSync(".git/info/sparse-checkout", sparsePath);
  try {
    await exec2(pullSource(branch));
    import_shelljs2.default.mv(filePath, import_path2.default.dirname(tempDownloadPath));
  } catch (error) {
    console.error("Error pulling git repository:", error);
    process.exit(1);
  } finally {
    import_shelljs2.default.cd("..");
    import_shelljs2.default.rm("-rf", tempDownloadName);
  }
}

// cli.ts
function cli(goGitIt2) {
  const args = process.argv;
  if (args.length < 3) {
    console.log("You need to provide a valid GitHub URL to start a download.");
    process.exit();
  }
  if (args.length === 3) {
    goGitIt2(args[args.length - 1]);
    process.exit();
  }
  if (args.length === 4) {
    goGitIt2(args[args.length - 2], args[args.length - 1]);
    process.exit();
  }
}

// getData.ts
var NO_BRANCH_FOUND = -1;
function getOwner(urlData) {
  return urlData.slice(1, 3)[0];
}
function getProject(urlData) {
  return urlData.slice(1, 3)[1];
}
function getFilePath(urlData) {
  const branch = urlData.findIndex((data) => data === "tree");
  if (branch !== NO_BRANCH_FOUND) {
    return urlData.slice(5).join("/");
  }
  return urlData.slice(3).join("/");
}
function getBranch(urlData) {
  const branch = urlData.findIndex((data) => data === "tree");
  if (branch !== NO_BRANCH_FOUND) {
    return urlData[4];
  }
  return "main";
}

// addProgressBar.ts
var import_progress = __toESM(require("progress"));
async function addProgressBar(text, completionCallback) {
  await new Promise(async (resolve, reject) => {
    const contentLength = 2048 * 1024;
    const bar = new import_progress.default(`${text} [:bar] :percent :etas`, {
      complete: "=",
      incomplete: " ",
      width: 50,
      total: contentLength
    });
    let progress = 0;
    const timer = setInterval(() => {
      const chunk = Math.random() * 10 * 1024;
      progress += chunk;
      bar.tick(chunk);
      if (progress >= contentLength || bar.complete) {
        clearInterval(timer);
      }
    }, 50);
    try {
      await completionCallback();
      clearInterval(timer);
      bar.tick(contentLength);
      resolve();
    } catch (error) {
      clearInterval(timer);
      console.error("[go-git-it] An error occurred:", error);
      reject(error);
    }
  });
}

// module.ts
async function cloneRemote(outputDirectory, options) {
  const { owner, project, isMainRepo } = options;
  if (isMainRepo) {
    await downloadMainRepo(outputDirectory, { owner, project });
  } else {
    await downloadPartialRepo(outputDirectory, options);
  }
}
async function goGitIt(gitURL, outputDirectory, text) {
  const urlData = new URL(gitURL).pathname.split("/");
  const remoteInfo = {
    owner: getOwner(urlData),
    project: getProject(urlData),
    filePath: getFilePath(urlData),
    branch: getBranch(urlData)
  };
  const filePath = remoteInfo.filePath || remoteInfo.project;
  const isMainRepo = filePath === remoteInfo.project;
  const outDir = outputDirectory || process.cwd();
  const remoteSource = `@${remoteInfo.owner}/${remoteInfo.project}`;
  await addProgressBar(
    text || `Downloading...${(0, import_safe.blue)(filePath)} from ${remoteSource}`,
    async () => {
      await cloneRemote(outDir, { ...remoteInfo, filePath, isMainRepo });
    }
  );
  if (!text) {
    console.log(
      `
Success! ${(0, import_safe.blue)(filePath)} downloaded to ${(0, import_safe.underline)(outDir + "/" + filePath)}`
    );
  }
}
if (require.main === module)
  cli(goGitIt);
var module_default = goGitIt;

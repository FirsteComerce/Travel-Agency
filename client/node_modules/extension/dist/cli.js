#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// cli.ts
var import_semver = __toESM(require("semver"));
var import_commander = require("commander");
var import_create = __toESM(require("@extension-create/create"));
var import_develop = require("@extension-create/develop");

// check-updates.ts
var import_update_check = __toESM(require("update-check"));
var import_safe = require("@colors/colors/safe");
async function checkUpdates(packageJson) {
  let update = null;
  try {
    update = await (0, import_update_check.default)(packageJson);
  } catch (err) {
    if (process.env.EXTENSION_ENV === "development") {
      console.error((0, import_safe.bold)((0, import_safe.red)(`Failed to check for updates: ${err}`)));
    }
  }
  if (update) {
    console.log(
      `
Your \u{1F9E9} ${(0, import_safe.bold)("Extension.js")} version is ${(0, import_safe.red)("outdated")}.
The latest version is ${(0, import_safe.bold)(update.latest)}. Please update!
`
    );
  }
}

// messages/blockingErrors.ts
var blockingErrors_exports = {};
__export(blockingErrors_exports, {
  noURLWithoutStart: () => noURLWithoutStart,
  notImplemented: () => notImplemented,
  unsupportedNodeVersion: () => unsupportedNodeVersion
});
function unsupportedNodeVersion() {
  return `
    You are using an unsupported Node version (${process.version}).

    Please update to a version higher than 18.
  `;
}
function noURLWithoutStart(argument) {
  return `
    The default \`create\` command does not accept URLs.
    Are you forgetting a \`start\` command? Maybe:

    npx extension \`start\` ${argument}
  `;
}
function notImplemented(argument) {
  return `${argument} command not implemented yet.`;
}

// messages/programHelp.ts
function programHelp() {
  return `
# Help center for the \u{1F9E9} Extension.js program

## Usage: \`extension [command] [options]\`

**Note:** If you are looking for a specific list of options,
all high-level commands offer their own \`--help\` file with
information about usage and a list of command flags available.

For example:

\`extension create --help\`
outputs information about the \`create\` command.

## Options available

\`extension create <extension-name>\`
Creates a new extension from template. The "create" command
is optional and can be ommitted.

\`extension dev <extension-path>\`
Starts a new browser instance in development mode, with the target
extension loaded and auto-reloaded based on file changes.

\`extension start <extension-path>\`
Starts a new browser instance in production mode, with the target
extension compiled based on the browser choice.

\`extension build <extension-path>\`
Builds the target extension with browser defaults, ready for packaging.

\`extension --help\`
This command ;) Outputs a help file with key command options.

Feels something is wrong? Help by reporting a bug:
https://github.com/cezaraugusto/extension/issues/new
`;
}

// messages/index.ts
var messages = {
  ...blockingErrors_exports,
  programHelp
};
var messages_default = messages;

// package.json
var package_default = {
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/cezaraugusto/extension.git",
    directory: "programs/cli"
  },
  engines: {
    node: ">=18"
  },
  name: "extension",
  version: "1.7.1",
  description: "Create cross-browser extensions with no build configuration.",
  main: "./dist/cli.js",
  types: "./dist/cli.d.ts",
  files: [
    "dist",
    "README.md"
  ],
  bin: {
    extension: "./dist/cli.js"
  },
  author: {
    name: "Cezar Augusto",
    email: "boss@cezaraugusto.net",
    url: "https://cezaraugusto.com"
  },
  scripts: {
    "compile:readme-files": "node ./scripts/copyMarkdownFilesToCli.js",
    "compile:tailwind-config": "node ./scripts/copyTailwindConfig.js",
    "compile:stylelint-config": "node ./scripts/copyStylelintConfig.js",
    "compile:cli": "tsup-node ./cli.ts --format cjs --dts --target=node18",
    compile: "yarn compile:readme-files && yarn compile:tailwind-config && yarn compile:stylelint-config &&yarn compile:cli",
    clean: "rm -rf dist",
    test: "jest"
  },
  keywords: [
    "zero-config",
    "build",
    "develop",
    "browser",
    "extension",
    "chrome extension",
    "edge extension",
    "firefox extension",
    "web",
    "react",
    "typescript"
  ],
  dependencies: {
    "@colors/colors": "^1.6.0",
    "@extension-create/create": "*",
    "@extension-create/develop": "*",
    commander: "^11.1.0",
    semver: "^7.5.4",
    "update-check": "^1.5.4"
  },
  devDependencies: {
    "@types/jest": "^29.5.11",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.11.5",
    "@types/semver": "^7.5.6",
    jest: "^29.7.0",
    "mock-fs": "^5.2.0",
    "ts-jest": "^29.1.2",
    tsconfig: "*",
    tsup: "^8.0.1",
    typescript: "5.3.3"
  }
};

// cli.ts
checkUpdates(package_default);
if (import_semver.default.lte(process.version, "18.0.0")) {
  messages_default.unsupportedNodeVersion();
  process.exit(1);
}
var extensionJs = import_commander.program;
if (process.env.EXTENSION_ENV === "development") {
  console.log(`Running extension via ${package_default.name}...`);
}
extensionJs.name(package_default.name).description(package_default.description).version(package_default.version).addHelpText("after", messages_default.programHelp());
var vendors = (browser) => browser === "all" ? "chrome,edge,firefox".split(",") : browser.split(",");
extensionJs.command("create").arguments("<project-name|project-path>").usage("create <project-name|project-path> [options]").description("Creates a new extension.").option(
  "-t, --template <template-name>",
  "specify a template for the created project"
).action(async function(pathOrRemoteUrl, {
  browser = "chrome",
  template,
  ...otherCommandOptions
}) {
  switch (pathOrRemoteUrl) {
    case "dev":
      for (const vendor of vendors(browser)) {
        await (0, import_develop.extensionDev)(pathOrRemoteUrl, {
          mode: "development",
          browser: vendor,
          ...otherCommandOptions
        });
      }
      break;
    case "start":
      for (const vendor of vendors(browser)) {
        await (0, import_develop.extensionStart)(pathOrRemoteUrl, {
          mode: "production",
          browser: vendor,
          ...otherCommandOptions
        });
      }
      break;
    case "build":
      for (const vendor of vendors(browser)) {
        await (0, import_develop.extensionBuild)(pathOrRemoteUrl, {
          browser: vendor,
          ...otherCommandOptions
        });
      }
      break;
    default:
      await (0, import_create.default)(pathOrRemoteUrl, { template });
      break;
  }
});
extensionJs.command("dev").arguments("[project-path|remote-url]").usage("dev [project-path|remote-url] [options]").description("Starts the development server (development mode)").option(
  "-u, --user-data-dir <path-to-file | boolean>",
  "what path to use for the browser profile. A boolean value of false sets the profile to the default user profile. Defaults to a fresh profile"
).option(
  "-b, --browser <chrome | edge | firefox>",
  "specify a browser to run your extension in development mode"
).option(
  "--polyfill [boolean]",
  "whether or not to apply the cross-browser polyfill. Defaults to `true`"
).option(
  "-p, --port <number>",
  "what port should Extension.js run. Defaults to `3000`"
).action(async function(pathOrRemoteUrl, { browser = "chrome", ...devOptions }) {
  for (const vendor of vendors(browser)) {
    await (0, import_develop.extensionDev)(pathOrRemoteUrl, {
      mode: "development",
      browser: vendor,
      ...devOptions
    });
  }
});
extensionJs.command("start").arguments("[project-path|remote-url]").usage("start [project-path|remote-url] [options]").description("Starts the development server (production mode)").option(
  "-u, --user-data-dir <path-to-file | boolean>",
  "what path to use for the browser profile. A boolean value of false sets the profile to the default user profile. Defaults to a fresh profile"
).option(
  "-b, --browser <chrome | edge | firefox>",
  "specify a browser to run your extension in development mode"
).option(
  "--polyfill [boolean]",
  "whether or not to apply the cross-browser polyfill. Defaults to `true`"
).option(
  "-p, --port <number>",
  "what port should Extension.js run. Defaults to `3000`"
).action(async function(pathOrRemoteUrl, { browser = "chrome", ...startOptions }) {
  for (const vendor of vendors(browser)) {
    await (0, import_develop.extensionStart)(pathOrRemoteUrl, {
      mode: "production",
      browser: vendor,
      ...startOptions
    });
  }
});
extensionJs.command("build").arguments("[project-name]").usage("build [path-to-remote-extension] [options]").description("Builds the extension for production").option(
  "-b, --browser <chrome | edge | firefox>",
  "specify a browser to run your extension in development mode"
).option(
  "--polyfill [boolean]",
  "whether or not to apply the cross-browser polyfill. Defaults to `false`"
).option(
  "--zip [boolean]",
  "whether or not to compress the extension into a ZIP file. Defaults to `false`"
).option(
  "--zip-source [boolean]",
  "whether or not to include the source files in the ZIP file. Defaults to `false`"
).option(
  "--zip-filename <string>",
  "specify the name of the ZIP file. Defaults to the extension name and version"
).action(async function(pathOrRemoteUrl, { browser = "chrome", ...buildOptions }) {
  for (const vendor of vendors(browser)) {
    await (0, import_develop.extensionBuild)(pathOrRemoteUrl, {
      browser: vendor,
      ...buildOptions
    });
  }
});
extensionJs.parse();
